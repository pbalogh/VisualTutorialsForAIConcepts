{
  "id": "engine-demo",
  "title": "Tutorial Engine Demo",
  "subtitle": "A self-documenting demonstration of the data-driven tutorial system",
  "state": {
    "correlationR": 0.65,
    "sampleSize": 50,
    "showAdvanced": false,
    "temperature": 72,
    "confidence": 0.95
  },
  "content": {
    "type": "Fragment",
    "children": [
      {
        "type": "Section",
        "props": {
          "title": "1. Live State Bindings"
        },
        "children": [
          {
            "type": "p",
            "children": [
              "This tutorial engine supports ",
              {
                "type": "strong",
                "children": "live state bindings"
              },
              {
                "type": "DeepDive",
                "props": {
                  "title": "Deep Dive: live state bindings",
                  "defaultOpen": true
                },
                "children": [
                  {
                    "type": "p",
                    "children": "Live state bindings are what make your user interface truly reactive - they create a direct, automatic connection between your application's data and what appears on screen. Unlike traditional approaches where you manually update the DOM whenever data changes, live bindings establish a persistent link that keeps everything synchronized without you having to think about it."
                  },
                  {
                    "type": "p",
                    "children": "Think of it like a smart mirror that automatically reflects any changes you make. When you bind a piece of state to a UI element, you're essentially saying \"whatever happens to this data, make sure the screen always shows the current version.\" For example, if you have a counter variable bound to a text element, every time that counter increments, the displayed number updates instantly - no additional code required. This happens because the binding system is constantly watching your state and pushing changes to the connected elements."
                  },
                  {
                    "type": "p",
                    "children": "This concept becomes especially powerful when combined with reactive programming patterns and component-based architectures. Live bindings work hand-in-hand with concepts like observables, computed properties, and state management systems. They're also the foundation that enables features like two-way data binding in forms, where user input automatically updates your application state while state changes flow back to update the form fields."
                  },
                  {
                    "type": "DeepDive",
                    "props": {
                      "title": "Deep Dive: two-way data binding",
                      "defaultOpen": true
                    },
                    "children": [
                      {
                        "type": "p",
                        "children": "Two-way data binding is what makes forms feel responsive and alive. Instead of manually writing code to sync form inputs with your application state in both directions, the framework automatically keeps them in perfect harmony. When a user types in an input field, your state updates instantly. When your code changes the state, the form field reflects that change immediately."
                      },
                      {
                        "type": "Example",
                        "props": {
                          "title": "Example: Username Field"
                        },
                        "children": [
                          {
                            "type": "Code",
                            "props": {
                              "language": "javascript"
                            },
                            "children": "// With two-way binding:\nconst [username, setUsername] = useState('');\n\n// This input stays in sync automatically\n<input \n  value={username} \n  onChange={e => setUsername(e.target.value)} \n/>\n\n// When username changes programmatically:\nsetUsername('john_doe'); // Input shows 'john_doe' instantly"
                          }
                        ]
                      },
                      {
                        "type": "Analogy",
                        "children": "Think of it like a mirror - when you move your hand (user input), your reflection moves instantly (state updates). When something changes your reflection from behind the mirror (programmatic state change), you see it immediately (form updates). The connection works both ways without you having to coordinate it manually."
                      },
                      {
                        "type": "ComparisonTable",
                        "props": {
                          "headers": [
                            "Without Two-Way Binding",
                            "With Two-Way Binding"
                          ],
                          "rows": [
                            [
                              "Manually read input values",
                              "State automatically syncs"
                            ],
                            [
                              "Manually update form fields",
                              "UI updates automatically"
                            ],
                            [
                              "Write separate event handlers",
                              "Single binding declaration"
                            ],
                            [
                              "Risk of state/UI mismatch",
                              "Always perfectly synchronized"
                            ]
                          ]
                        }
                      },
                      {
                        "type": "ul",
                        "children": [
                          {
                            "type": "li",
                            "children": "User input immediately updates application state"
                          },
                          {
                            "type": "li",
                            "children": "State changes instantly reflect in form fields"
                          },
                          {
                            "type": "li",
                            "children": "No manual synchronization code needed"
                          },
                          {
                            "type": "li",
                            "children": "Prevents bugs from state/UI mismatches"
                          },
                          {
                            "type": "li",
                            "children": "Enables real-time validation and dynamic forms"
                          }
                        ]
                      },
                      {
                        "type": "Callout",
                        "props": {
                          "type": "tip"
                        },
                        "children": "This is why reactive systems are so powerful for forms - they eliminate the tedious and error-prone work of keeping your UI and state synchronized, letting you focus on your application logic instead of plumbing code."
                      }
                    ]
                  },
                  {
                    "type": "DeepDive",
                    "props": {
                      "title": "Deep Dive: reactive programming patterns",
                      "defaultOpen": true
                    },
                    "children": [
                      {
                        "type": "p",
                        "children": "Reactive programming patterns are the secret sauce that makes live bindings truly powerful. Instead of your code constantly checking \"has something changed?\", reactive patterns flip the script: data announces when it changes, and everything that depends on it automatically updates. This creates a flowing, declarative system where you describe what should happen, not when or how to make it happen."
                      },
                      {
                        "type": "Code",
                        "props": {
                          "language": "javascript"
                        },
                        "children": "// Traditional approach - manual checking\nfunction updateTotal() {\n  if (price !== oldPrice || quantity !== oldQuantity) {\n    total = price * quantity;\n    updateDisplay();\n  }\n}\n\n// Reactive approach - automatic flow\nconst total = computed(() => price.value * quantity.value);\n// total updates automatically when price or quantity changes"
                      },
                      {
                        "type": "p",
                        "children": "The magic happens through three core patterns: observables (data that broadcasts changes), computed properties (derived values that recalculate automatically), and reactive effects (side effects that run when dependencies change). When you combine these with live bindings, you get a data flow where changes in one place ripple through your entire application without you having to orchestrate each update."
                      },
                      {
                        "type": "Blockquote",
                        "children": "Think of it like a spreadsheet: change one cell, and all the formulas that reference it update instantly. Reactive patterns bring this same automatic dependency tracking to your applications."
                      },
                      {
                        "type": "p",
                        "children": "This connects directly to the component-based architectures mentioned in the tutorial. Each component can declare its reactive dependencies, and the framework ensures that only the components affected by a change actually re-render. It's also what makes state management systems so powerfulâ€”your global state becomes a reactive source of truth that components can tap into."
                      },
                      {
                        "type": "Callout",
                        "props": {
                          "type": "tip"
                        },
                        "children": "Now you can think beyond manual updates. When designing live bindings, ask: \"What should automatically respond to this change?\" instead of \"Where do I need to trigger updates?\" This shift in thinking leads to more maintainable, bug-free applications."
                      }
                    ]
                  },
                  {
                    "type": "p",
                    "children": "Now you can build interfaces that feel fluid and responsive without writing tedious update logic. Instead of manually tracking what needs to change when data updates, you can focus on defining the relationships between your data and UI once, then let the binding system handle all the synchronization work for you."
                  }
                ]
              },
              ". Variables defined in the JSON are reactive â€” when one component changes a value, all other components that reference it update instantly."
            ]
          },
          {
            "type": "InteractiveCard",
            "children": [
              {
                "type": "p",
                "children": [
                  "Current correlation value: ",
                  {
                    "type": "StateValue",
                    "props": {
                      "bind": "correlationR",
                      "format": ".2f"
                    }
                  },
                  ". With a sample size of ",
                  {
                    "type": "StateValue",
                    "props": {
                      "bind": "sampleSize",
                      "format": ".0f"
                    }
                  },
                  ", this represents a ",
                  {
                    "type": "StateComputed",
                    "props": {
                      "compute": "correlationR > 0.7 ? 'strong' : correlationR > 0.4 ? 'moderate' : 'weak'"
                    }
                  },
                  " relationship."
                ]
              },
              {
                "type": "Slider",
                "props": {
                  "bind": "correlationR",
                  "min": -1,
                  "max": 1,
                  "step": 0.01,
                  "label": "Correlation (r)"
                }
              },
              {
                "type": "Slider",
                "props": {
                  "bind": "sampleSize",
                  "min": 10,
                  "max": 200,
                  "step": 10,
                  "label": "Sample Size (n)"
                }
              }
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "tip"
            },
            "children": "Try dragging the sliders above. Notice how the text updates in real-time!"
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "2. Conditional Content"
        },
        "children": [
          {
            "type": "p",
            "children": "Content can appear or disappear based on state values. Toggle the switch below:"
          },
          {
            "type": "Toggle",
            "props": {
              "bind": "showAdvanced",
              "label": "Show advanced content"
            }
          },
          {
            "type": "StateConditional",
            "props": {
              "when": "showAdvanced"
            },
            "children": {
              "type": "Card",
              "props": {
                "className": "border-purple-200 bg-purple-50"
              },
              "children": [
                {
                  "type": "h3",
                  "props": {
                    "className": "text-lg font-bold text-purple-800 mb-2"
                  },
                  "children": "ðŸ”¬ Advanced Section"
                },
                {
                  "type": "p",
                  "children": [
                    "This section only appears when 'Show advanced content' is enabled. ",
                    "The current confidence level is ",
                    {
                      "type": "StateValue",
                      "props": {
                        "bind": "confidence",
                        "format": ".0%"
                      }
                    },
                    "."
                  ]
                },
                {
                  "type": "Slider",
                  "props": {
                    "bind": "confidence",
                    "min": 0.5,
                    "max": 0.99,
                    "step": 0.01,
                    "label": "Confidence Level"
                  }
                }
              ]
            }
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "3. Computed Expressions"
        },
        "children": [
          {
            "type": "p",
            "children": [
              "StateComputed allows arbitrary JavaScript expressions. For example, with r = ",
              {
                "type": "StateValue",
                "props": {
                  "bind": "correlationR",
                  "format": ".2f"
                }
              },
              ":"
            ]
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": [
                  "rÂ² (coefficient of determination) = ",
                  {
                    "type": "Callout",
                    "props": {
                      "type": "info"
                    },
                    "children": [
                      {
                        "type": "strong",
                        "children": "ðŸ’¡ \"coefficient of determination\":"
                      },
                      " ",
                      "In this context, the coefficient of determination (rÂ²) tells you how well your model explains the variation in your data. When you square the correlation coefficient r, you get a percentage that represents how much of the \"scatter\" or variability in your outcome can be predicted by your input variables. Here, an rÂ² of 0.4225 means your model accounts for about 42% of why the data points vary, while the remaining 58% is due to other factors not captured in your model.",
                      " ",
                      {
                        "type": "em",
                        "props": {
                          "className": "text-gray-400 text-xs"
                        },
                        "children": "(2/5/2026, 2:49:53 PM)"
                      }
                    ]
                  },
                  {
                    "type": "StateComputed",
                    "props": {
                      "compute": "(correlationR * correlationR).toFixed(4)"
                    }
                  }
                ]
              },
              {
                "type": "li",
                "children": [
                  "Interpretation: ",
                  {
                    "type": "StateComputed",
                    "props": {
                      "compute": "Math.round(correlationR * correlationR * 100) + '% of variance explained'"
                    }
                  }
                ]
              },
              {
                "type": "li",
                "children": [
                  "Direction: ",
                  {
                    "type": "StateComputed",
                    "props": {
                      "compute": "correlationR > 0 ? 'positive â†—' : correlationR < 0 ? 'negative â†˜' : 'none â†’'"
                    }
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "4. Layout Components"
        },
        "children": [
          {
            "type": "p",
            "children": "The engine includes several layout primitives:"
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "This is an INFO callout â€” use it for helpful tips."
          },
          {
            "type": "Callout",
            "props": {
              "type": "warning"
            },
            "children": "This is a WARNING callout â€” use it for important caveats."
          },
          {
            "type": "Callout",
            "props": {
              "type": "success"
            },
            "children": "This is a SUCCESS callout â€” use it for positive confirmations."
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "Click to expand this Deep Dive section"
            },
            "children": [
              {
                "type": "p",
                "children": "DeepDive components are collapsible sections perfect for optional detailed explanations. They start collapsed by default."
              },
              {
                "type": "p",
                "children": [
                  "Even inside a DeepDive, state bindings work: temperature is ",
                  {
                    "type": "StateValue",
                    "props": {
                      "bind": "temperature",
                      "format": ".0f"
                    }
                  },
                  "Â°F."
                ]
              },
              {
                "type": "Slider",
                "props": {
                  "bind": "temperature",
                  "min": 32,
                  "max": 100,
                  "step": 1,
                  "label": "Temperature (Â°F)"
                }
              }
            ]
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "5. Code Blocks"
        },
        "children": [
          {
            "type": "p",
            "children": "Code can be displayed with syntax highlighting (basic for now):"
          },
          {
            "type": "Code",
            "props": {
              "language": "javascript"
            },
            "children": "// The state is defined in JSON:\n{\n  \"state\": {\n    \"correlationR\": 0.65,\n    \"sampleSize\": 50\n  }\n}\n\n// Components bind to it:\n<StateValue bind=\"correlationR\" format=\".2f\" />"
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "6. AI-Powered Annotations"
        },
        "children": [
          {
            "type": "p",
            "children": "Select any text on this page and click 'Explain' or 'Go Deeper' to generate AI-powered contextual explanations. The AI understands what you're reading and explains concepts in context, not just generic definitions."
          },
          {
            "type": "Callout",
            "props": {
              "type": "tip"
            },
            "children": "Try selecting a phrase like 'coefficient of determination' above â€” the AI will explain what it means in the context of correlation analysis!"
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "How It Works"
        },
        "children": [
          {
            "type": "p",
            "children": "This entire tutorial is defined as a JSON file. The TutorialEngine recursively renders it using a component registry. Each element has a 'type' (component name) and optional 'props' and 'children'."
          },
          {
            "type": "p",
            "children": "When you request an annotation, the server calls Claude (via AWS Bedrock or Anthropic API), generates contextual content, inserts it into the JSON, and commits to Git â€” all automatically."
          }
        ]
      }
    ]
  }
}