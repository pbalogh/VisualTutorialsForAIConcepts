{
  "id": "rotate-paper",
  "title": "RotatE Paper: Annotated Tutorial",
  "subtitle": "Knowledge Graph Embedding by Relational Rotation in Complex Space — Sun et al., ICLR 2019",
  "readTime": "45 min",
  "state": {},
  "content": {
    "type": "Fragment",
    "children": [
      {
        "type": "Callout",
        "props": {
          "type": "info"
        },
        "children": "This is an annotated, interactive version of the RotatE paper. Original: arxiv.org/abs/1902.10197. Annotations explain concepts in plain English and connect to Schankian operator research."
      },
      {
        "type": "Section",
        "props": {
          "title": "1. The Big Picture"
        },
        "children": [
          {
            "type": "h3",
            "children": "What Problem Does RotatE Solve?"
          },
          {
            "type": "p",
            "children": "Knowledge graphs store facts as triples: (head, relation, tail). For example: (Obama, bornIn, Hawaii). The problem: knowledge graphs are always incomplete. Can we predict missing links?"
          },
          {
            "type": "Example",
            "props": {
              "title": "Link Prediction"
            },
            "children": [
              {
                "type": "p",
                "children": "Given: (Obama, bornIn, ?)"
              },
              {
                "type": "p",
                "children": "Predict: Hawaii"
              },
              {
                "type": "p",
                "children": "Or given: (?, presidentOf, USA)"
              },
              {
                "type": "p",
                "children": "Predict: Obama, Biden, Trump, ..."
              }
            ]
          },
          {
            "type": "h3",
            "children": "The Key Insight"
          },
          {
            "type": "Callout",
            "props": {
              "type": "tip"
            },
            "children": "RotatE models relations as ROTATIONS in complex vector space. If you rotate the head entity by the relation angle, you should arrive at the tail entity."
          },
          {
            "type": "p",
            "children": "Mathematically: t = h ⊙ r, where ⊙ is element-wise multiplication of complex numbers, and |r| = 1 (unit complex number = rotation)."
          },
          {
            "type": "ComplexRotationViz",
            "props": {
              "initialAngle": 45
            }
          },
          {
            "type": "h3",
            "children": "Why Rotations?"
          },
          {
            "type": "p",
            "children": "Previous models had limitations:"
          },
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Model",
                "Approach",
                "Can't Handle"
              ],
              "rows": [
                [
                  "TransE",
                  "h + r ≈ t (translation)",
                  "Symmetric relations (married_to)"
                ],
                [
                  "DistMult",
                  "⟨h, r, t⟩ (dot product)",
                  "Antisymmetric relations (parent_of)"
                ],
                [
                  "ComplEx",
                  "Re(⟨h, r, t̄⟩)",
                  "Composition (grandfather = father ∘ father)"
                ]
              ]
            }
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "❓ Why does TransE fail on symmetric relations?",
              "defaultOpen": false
            },
            "children": [
              {
                "type": "p",
                "children": [
                  "TransE requires h + r = t",
                  {
                    "type": "FootnoteRef",
                    "props": {
                      "id": "source-ann-1770463906274-qphm1j",
                      "targetId": "ann-1770463906274-qphm1j",
                      "type": "ask"
                    }
                  },
                  ". For a symmetric relation like 'married_to', we need BOTH h + r = t AND t + r = h to hold."
                ]
              },
              {
                "type": "p",
                "children": "Adding these: (h + t) + 2r = (h + t), which forces r = 0."
              },
              {
                "type": "p",
                "children": "So TransE learns r = 0 for all symmetric relations — entities connected by symmetric relations become indistinguishable!"
              },
              {
                "type": "p",
                "children": "RotatE solves this: symmetric relations are 180° rotations (r = -1). Rotating twice returns to start: (-1)×(-1) = 1."
              }
            ]
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "❓ Q: Can you flesh this out with a toy example that makes this concrete? And show a little more about how they represent entities and relations?",
              "defaultOpen": true,
              "id": "ann-1770463906274-qphm1j",
              "sourceId": "source-ann-1770463906274-qphm1j"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info"
                },
                "children": [
                  {
                    "type": "em",
                    "children": "About \"TransE requires h + r = t\""
                  }
                ]
              },
              {
                "type": "p",
                "children": "In TransE, entities and relations are represented as vectors in the same dimensional space - think of them as points or directions in a coordinate system. For example, \"Paris\" might be the vector [0.2, -0.5, 0.8] and \"capital_of\" might be [0.1, 0.3, -0.2]."
              },
              {
                "type": "p",
                "children": "The core idea h + r = t means that if you start at the head entity's position, then move in the direction specified by the relation vector, you should end up at the tail entity's position. So if we have the fact \"Paris capital_of France\", TransE learns vectors such that Paris + capital_of ≈ France. Concretely, this might be [0.2, -0.5, 0.8] + [0.1, 0.3, -0.2] = [0.3, -0.2, 0.6], which should be close to France's learned vector."
              },
              {
                "type": "p",
                "children": "This works well for asymmetric relations like \"capital_of\" where there's a clear directional relationship. But as the passage points out, symmetric relations create problems because \"John married_to Mary\" and \"Mary married_to John\" are both true, yet TransE would need both John + married_to = Mary AND Mary + married_to = John. Since addition isn't symmetric (if A + B = C, then C + B doesn't equal A unless B = 0), TransE struggles with these cases - which is exactly the motivation for developing RotatE."
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-4"
                },
                "children": "(2/7/2026, 6:31:36 AM)"
              }
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "success"
            },
            "children": "RotatE handles ALL THREE patterns: symmetry, antisymmetry, inversion, AND composition. This is the main contribution."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "2. Three Relation Patterns"
        },
        "children": [
          {
            "type": "p",
            "children": "The paper identifies three critical patterns that any good model should handle:"
          },
          {
            "type": "h3",
            "children": "Pattern 1: Symmetry / Antisymmetry"
          },
          {
            "type": "p",
            "children": "Symmetric: If r(x,y) then r(y,x). Example: married_to, similar_to"
          },
          {
            "type": "p",
            "children": "Antisymmetric: If r(x,y) then NOT r(y,x). Example: parent_of, older_than"
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "RotatE solution: A relation r is symmetric iff r = ±1 (rotation by 0° or 180°). For any other angle, it's antisymmetric."
          },
          {
            "type": "h3",
            "children": "Pattern 2: Inversion"
          },
          {
            "type": "p",
            "children": "r₁ is inverse of r₂ if: r₂(x,y) implies r₁(y,x). Example: hypernym/hyponym, parent/child"
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "RotatE solution: r₂ = r̄₁ (complex conjugate). Rotating by θ then by -θ gets you back to start."
          },
          {
            "type": "h3",
            "children": "Pattern 3: Composition"
          },
          {
            "type": "p",
            "children": "r₃ = r₁ ∘ r₂ if: r₁(x,y) AND r₂(y,z) implies r₃(x,z). Example: grandfather = father ∘ father"
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "RotatE solution: r₃ = r₁ ⊙ r₂. Rotation angles ADD: θ₃ = θ₁ + θ₂. This is why complex numbers are perfect!"
          },
          {
            "type": "Example",
            "props": {
              "title": "Composition Example"
            },
            "children": [
              {
                "type": "p",
                "children": "father = rotation by 30°"
              },
              {
                "type": "p",
                "children": "grandfather = father ∘ father = rotation by 60°"
              },
              {
                "type": "p",
                "children": "great-grandfather = rotation by 90°"
              },
              {
                "type": "p",
                "children": "The angles compose naturally via complex multiplication!"
              }
            ]
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "3. The RotatE Model"
        },
        "children": [
          {
            "type": "h3",
            "children": "Core Equation"
          },
          {
            "type": "p",
            "children": "For a triple (h, r, t), we want:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "t = h ⊙ r\n\nwhere:\n  h, t ∈ ℂᵏ  (k-dimensional complex vectors)\n  r ∈ ℂᵏ with |rᵢ| = 1 (unit complex = rotation)\n  ⊙ = element-wise (Hadamard) product"
          },
          {
            "type": "p",
            "children": "For each dimension i:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "tᵢ = hᵢ × rᵢ\n\nSince |rᵢ| = 1, we can write rᵢ = e^(iθᵢ)\nThis rotates hᵢ by angle θᵢ in the complex plane"
          },
          {
            "type": "h3",
            "children": "Distance (Scoring) Function"
          },
          {
            "type": "p",
            "children": "To score a triple, RotatE measures how close h⊙r is to t:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "d(h, r, t) = ||h ⊙ r - t||\n\nLower distance = better match\nA perfect triple has distance 0"
          },
          {
            "type": "h3",
            "children": "Training: Negative Sampling"
          },
          {
            "type": "p",
            "children": "The model learns by contrasting true triples with corrupted (false) triples:"
          },
          {
            "type": "Code",
            "props": {
              "language": "python"
            },
            "children": "# Loss function:\nL = -log(σ(γ - d(h,r,t)))           # True triple: distance < margin γ\n  - Σ log(σ(d(h',r,t') - γ))        # False triples: distance > margin γ\n\n# σ = sigmoid, γ = margin (hyperparameter)"
          },
          {
            "type": "Callout",
            "props": {
              "type": "tip"
            },
            "children": "Self-adversarial negative sampling: Sample harder negatives based on current embeddings. Triples that currently score well (but are false) are weighted more heavily."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "4. Why Each Pattern Works"
        },
        "children": [
          {
            "type": "h3",
            "children": "Symmetry: r = ±1"
          },
          {
            "type": "p",
            "children": "If r(x,y) and r(y,x) both hold, then:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "y = x ⊙ r  (from first triple)\nx = y ⊙ r  (from second triple)\n\nSubstituting: x = (x ⊙ r) ⊙ r = x ⊙ r²\n\nThis requires r² = 1, so r = ±1\n\nr = +1: rotation by 0° (identity)\nr = -1: rotation by 180°"
          },
          {
            "type": "h3",
            "children": "Inversion: r₂ = r̄₁"
          },
          {
            "type": "p",
            "children": "If r₁(x,y) and r₂(y,x), then r₂ = r̄₁ (complex conjugate):"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "y = x ⊙ r₁  →  x = y ⊙ r₂\n\nFor this to work: r₁ ⊙ r₂ = 1\n\nSo r₂ = 1/r₁ = r̄₁ (conjugate, since |r₁| = 1)"
          },
          {
            "type": "h3",
            "children": "Composition: r₃ = r₁ ⊙ r₂"
          },
          {
            "type": "p",
            "children": "If r₁(x,y) and r₂(y,z), then r₃(x,z) where r₃ = r₁ ⊙ r₂:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "y = x ⊙ r₁\nz = y ⊙ r₂ = (x ⊙ r₁) ⊙ r₂ = x ⊙ (r₁ ⊙ r₂)\n\nSo z = x ⊙ r₃ where r₃ = r₁ ⊙ r₂\n\nIn terms of angles: θ₃ = θ₁ + θ₂"
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "5. Comparison to Other Models"
        },
        "children": [
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Model",
                "Score Function",
                "Symmetry",
                "Antisymmetry",
                "Inversion",
                "Composition"
              ],
              "rows": [
                [
                  "TransE",
                  "||h + r - t||",
                  "❌",
                  "✅",
                  "✅",
                  "✅"
                ],
                [
                  "DistMult",
                  "⟨h, r, t⟩",
                  "✅",
                  "❌",
                  "❌",
                  "❌"
                ],
                [
                  "ComplEx",
                  "Re(⟨h, r, t̄⟩)",
                  "✅",
                  "✅",
                  "✅",
                  "❌"
                ],
                [
                  "RotatE",
                  "||h ⊙ r - t||",
                  "✅",
                  "✅",
                  "✅",
                  "✅"
                ]
              ]
            }
          },
          {
            "type": "Callout",
            "props": {
              "type": "success"
            },
            "children": "RotatE is the ONLY model that handles all four patterns. This is why it achieves state-of-the-art on benchmarks."
          },
          {
            "type": "h3",
            "children": "Why TransE Fails on Symmetry"
          },
          {
            "type": "p",
            "children": "TransE uses: t = h + r. For symmetric relations where h→t and t→h both hold:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "t = h + r  and  h = t + r\n\nSubtracting: 0 = 2r, so r = 0\n\nAll symmetric relations collapse to r = 0!\nEntities with symmetric relations get pushed together."
          },
          {
            "type": "p",
            "children": "RotatE avoids this because rotation by 180° (r = -1) is a valid non-zero representation."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "6. Experimental Results"
        },
        "children": [
          {
            "type": "h3",
            "children": "Benchmark Datasets"
          },
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Dataset",
                "Entities",
                "Relations",
                "Main Patterns"
              ],
              "rows": [
                [
                  "FB15k",
                  "14,951",
                  "1,345",
                  "Symmetry, Inversion"
                ],
                [
                  "WN18",
                  "40,943",
                  "18",
                  "Symmetry, Inversion"
                ],
                [
                  "FB15k-237",
                  "14,541",
                  "237",
                  "Composition (inverse relations removed)"
                ],
                [
                  "WN18RR",
                  "40,943",
                  "11",
                  "Symmetry, Composition"
                ]
              ]
            }
          },
          {
            "type": "h3",
            "children": "Key Results"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "RotatE achieves state-of-the-art on ALL benchmarks"
              },
              {
                "type": "li",
                "children": "Especially strong on FB15k-237 and WN18RR (composition-heavy)"
              },
              {
                "type": "li",
                "children": "pRotatE (phase-only variant) also works but worse on composition"
              },
              {
                "type": "li",
                "children": "Self-adversarial negative sampling helps significantly"
              }
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "The modulus of entity embeddings (not just phase) is critical for composition patterns. This is why full RotatE beats pRotatE."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "7. Connection to Schankian Operators"
        },
        "children": [
          {
            "type": "Callout",
            "props": {
              "type": "warning"
            },
            "children": "This section connects RotatE to your research on learned Schankian operators."
          },
          {
            "type": "h3",
            "children": "What We Borrow from RotatE"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "Complex vector embeddings for entities"
              },
              {
                "type": "li",
                "children": "Relations (operators) as rotations"
              },
              {
                "type": "li",
                "children": "Margin-based ranking loss"
              },
              {
                "type": "li",
                "children": "The scoring function ||h ⊙ r - t||"
              }
            ]
          },
          {
            "type": "h3",
            "children": "How We Extend RotatE"
          },
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Aspect",
                "RotatE",
                "Schankian Operators"
              ],
              "rows": [
                [
                  "Domain",
                  "Static knowledge graphs",
                  "Event semantics / narratives"
                ],
                [
                  "Triples",
                  "(entity, relation, entity)",
                  "(agent, operator, patient)"
                ],
                [
                  "Goal",
                  "Link prediction",
                  "Learn semantic primitives"
                ],
                [
                  "Relations",
                  "Pre-defined in KG",
                  "Discovered from data"
                ],
                [
                  "Asymmetry",
                  "Some relations",
                  "ALL operators (agent ≠ patient)"
                ]
              ]
            }
          },
          {
            "type": "h3",
            "children": "Key Insight"
          },
          {
            "type": "p",
            "children": "RotatE proves that rotation-based operators can capture complex relational patterns. We apply this to EVENT semantics:"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "'cop shot frank' → HARM(cop, frank)"
              },
              {
                "type": "li",
                "children": "'frank shot cop' → HARM(frank, cop) — DIFFERENT!"
              },
              {
                "type": "li",
                "children": "Non-commutativity is built into the rotation framework"
              }
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "tip"
            },
            "children": "Our Phase 1 experiment (88% operator recovery) validates that RotatE's approach works for learning Schankian-style operators from data."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "8. Implementation Details"
        },
        "children": [
          {
            "type": "h3",
            "children": "Hyperparameters"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "Embedding dimension k: 125, 250, 500, or 1000"
              },
              {
                "type": "li",
                "children": "Batch size: 512, 1024, or 2048"
              },
              {
                "type": "li",
                "children": "Margin γ: 3 to 30"
              },
              {
                "type": "li",
                "children": "Self-adversarial temperature α: 0.5 or 1.0"
              },
              {
                "type": "li",
                "children": "Optimizer: Adam"
              },
              {
                "type": "li",
                "children": "No regularization (margin prevents overfitting)"
              }
            ]
          },
          {
            "type": "h3",
            "children": "Initialization"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "Entity embeddings: uniform random (real + imaginary parts)"
              },
              {
                "type": "li",
                "children": "Relation phases: uniform in [0, 2π]"
              }
            ]
          },
          {
            "type": "h3",
            "children": "Code"
          },
          {
            "type": "p",
            "children": "Official implementation: github.com/DeepGraphLearning/KnowledgeGraphEmbedding"
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "Key Takeaways"
        },
        "children": [
          {
            "type": "ol",
            "children": [
              {
                "type": "li",
                "children": "Relations as rotations: t = h ⊙ r where |r| = 1"
              },
              {
                "type": "li",
                "children": "Handles ALL patterns: symmetry, antisymmetry, inversion, composition"
              },
              {
                "type": "li",
                "children": "Composition = angle addition: θ₃ = θ₁ + θ₂"
              },
              {
                "type": "li",
                "children": "Self-adversarial sampling improves training"
              },
              {
                "type": "li",
                "children": "State-of-the-art on all major KG benchmarks"
              },
              {
                "type": "li",
                "children": "Foundation for our Schankian operator research"
              }
            ]
          }
        ]
      }
    ]
  }
}