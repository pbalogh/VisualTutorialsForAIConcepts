{
  "id": "rotate-paper",
  "title": "RotatE Paper: Annotated Tutorial",
  "subtitle": "Knowledge Graph Embedding by Relational Rotation in Complex Space — Sun et al., ICLR 2019",
  "readTime": "45 min",
  "state": {},
  "content": {
    "type": "Fragment",
    "children": [
      {
        "type": "Callout",
        "props": {
          "type": "info"
        },
        "children": "This is an annotated, interactive version of the RotatE paper. Original: arxiv.org/abs/1902.10197. Annotations explain concepts in plain English and connect to Schankian operator research."
      },
      {
        "type": "Section",
        "props": {
          "title": "1. The Big Picture"
        },
        "children": [
          {
            "type": "h3",
            "children": "What Problem Does RotatE Solve?"
          },
          {
            "type": "p",
            "children": "Knowledge graphs store facts as triples: (head, relation, tail). For example: (Obama, bornIn, Hawaii). The problem: knowledge graphs are always incomplete. Can we predict missing links?"
          },
          {
            "type": "Example",
            "props": {
              "title": "Link Prediction"
            },
            "children": [
              {
                "type": "p",
                "children": "Given: (Obama, bornIn, ?)"
              },
              {
                "type": "p",
                "children": "Predict: Hawaii"
              },
              {
                "type": "p",
                "children": "Or given: (?, presidentOf, USA)"
              },
              {
                "type": "p",
                "children": "Predict: Obama, Biden, Trump, ..."
              }
            ]
          },
          {
            "type": "h3",
            "children": "The Key Insight"
          },
          {
            "type": "Callout",
            "props": {
              "type": "tip"
            },
            "children": "RotatE models relations as ROTATIONS in complex vector space. If you rotate the head entity by the relation angle, you should arrive at the tail entity."
          },
          {
            "type": "p",
            "children": "Mathematically: t = h ⊙ r, where ⊙ is element-wise multiplication of complex numbers, and |r| = 1 (unit complex number = rotation)."
          },
          {
            "type": "ComplexRotationViz",
            "props": {
              "initialAngle": 45
            }
          },
          {
            "type": "h3",
            "children": "Why Rotations?"
          },
          {
            "type": "p",
            "children": "Previous models had limitations:"
          },
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Model",
                "Approach",
                "Can't Handle"
              ],
              "rows": [
                [
                  "TransE",
                  "h + r ≈ t (translation)",
                  "Symmetric relations (married_to)"
                ],
                [
                  "DistMult",
                  "⟨h, r, t⟩ (dot product)",
                  "Antisymmetric relations (parent_of)"
                ],
                [
                  "ComplEx",
                  "Re(⟨h, r, t̄⟩)",
                  "Composition (grandfather = father ∘ father)"
                ]
              ],
              "highlightRows": [
                1
              ],
              "highlightId": "ann-1770464450203-oj2nkl"
            }
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "❓ Q: Can you flesh this out the way you did with TransE?",
              "defaultOpen": true,
              "id": "ann-1770464450203-oj2nkl",
              "sourceId": "source-ann-1770464450203-oj2nkl"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info"
                },
                "children": [
                  {
                    "type": "em",
                    "children": "About \"DistMult\""
                  }
                ]
              },
              {
                "type": "p",
                "children": "DistMult is another fundamental knowledge graph embedding method that takes a very different approach from TransE. While TransE models relationships as translations in vector space (h + r ≈ t), DistMult models them as element-wise multiplications."
              },
              {
                "type": "p",
                "children": "In DistMult, entities are represented as vectors and relations are represented as diagonal matrices (or equivalently, vectors). The scoring function is simply the dot product: score(h,r,t) = h^T diag(r) t = Σᵢ hᵢ × rᵢ × tᵢ. This means DistMult captures how well entities \"match\" through a relation by measuring their component-wise compatibility."
              },
              {
                "type": "p",
                "children": [
                  "However, DistMult has a critical limitation that RotatE aims to address: it's symmetric by design. Since multiplication is commutative (h × r × t = t × r × h), DistMult cannot distinguish",
                  {
                    "type": "FootnoteRef",
                    "props": {
                      "id": "source-ann-1770464568269-xgf8h5",
                      "targetId": "ann-1770464568269-xgf8h5",
                      "type": "ask"
                    }
                  },
                  " between (head, relation, tail) and (tail, relation, head). This makes it impossible to model asymmetric relations like \"parent_of\" - if John is the parent of Mary, DistMult would incorrectly suggest Mary is also the parent of John."
                ]
              },
              {
                "type": "p",
                "children": "This symmetry constraint is exactly what motivated the development of more sophisticated models like RotatE, which uses complex rotations to capture both symmetric patterns (like DistMult's strengths) and asymmetric patterns (addressing DistMult's key weakness) in a unified framework."
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-4"
                },
                "children": "(2/7/2026, 6:40:41 AM)"
              }
            ]
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "❓ Q: Isn't this just the inevitable result of using a diagonal matrix? Why didn't they use a more robust, freeform matrix?",
              "defaultOpen": true,
              "id": "ann-1770464568269-xgf8h5",
              "sourceId": "source-ann-1770464568269-xgf8h5"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info"
                },
                "children": [
                  {
                    "type": "em",
                    "children": "About \"DistMult cannot distinguish\""
                  }
                ]
              },
              {
                "type": "p",
                "children": "You're absolutely right that this is a consequence of DistMult's design choice to use diagonal matrices! The designers of DistMult deliberately chose this constrained approach for computational efficiency and to reduce overfitting, not because they couldn't think of using full matrices."
              },
              {
                "type": "p",
                "children": "A full matrix would indeed be more expressive, but it comes with major trade-offs. With diagonal matrices, DistMult only needs to learn one parameter per dimension for each relation, making it fast and less prone to memorizing the training data. A full matrix would require learning d² parameters per relation (where d is the embedding dimension), making it computationally expensive and more likely to overfit, especially when training data is limited."
              },
              {
                "type": "p",
                "children": [
                  "The real insight of the RotatE paper isn't just pointing out this limitation - it's showing how to get the best of both worlds. RotatE achieves the asymmetry that full matrices could provide, but does so with the same parameter efficiency as diagonal matrices. Instead of using more parameters, it uses complex numbers and rotation operations to elegantly encode directional relationships. This is why RotatE is considered an advancement: it solves the asymmetry problem",
                  {
                    "type": "FootnoteRef",
                    "props": {
                      "id": "source-ann-1770464691587-75xkbd",
                      "targetId": "ann-1770464691587-75xkbd",
                      "type": "ask"
                    }
                  },
                  " without sacrificing the computational benefits that made DistMult attractive in the first place."
                ]
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-4"
                },
                "children": "(2/7/2026, 6:42:38 AM)"
              }
            ]
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "❓ Q: What worries me, though, is that rotating a vector in multiple dimensions will only work if the target vector has the same shape across all dimensions, no? If the target is much larger or smaller in one particular dimension, how can rotation work at getting us to it?",
              "defaultOpen": true,
              "id": "ann-1770464691587-75xkbd",
              "sourceId": "source-ann-1770464691587-75xkbd"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info"
                },
                "children": [
                  {
                    "type": "em",
                    "children": "About \"solves the asymmetry problem\""
                  }
                ]
              },
              {
                "type": "p",
                "children": "You're thinking about rotation too literally - like rotating a physical object where the shape must be preserved. In RotatE, \"rotation\" is actually element-wise multiplication by complex numbers, which allows both rotation AND scaling simultaneously."
              },
              {
                "type": "p",
                "children": "Here's what actually happens: each dimension of the relation embedding is a complex number with both magnitude and phase. When you multiply the head entity by this complex relation, you're not just rotating - you're rotating each dimension by a potentially different angle AND scaling it by a potentially different amount. The magnitude of each complex number controls the scaling, while the phase controls the rotation."
              },
              {
                "type": "p",
                "children": "So if your target vector needs to be much larger in dimension 3 but smaller in dimension 1, the relation embedding can have a large magnitude in dimension 3 (strong scaling up) and small magnitude in dimension 1 (scaling down), each with their own rotation angles. This is why RotatE can capture the same expressiveness as full matrix transformations - it's not constrained to rigid rotations that preserve vector length and shape."
              },
              {
                "type": "p",
                "children": "This element-wise approach means RotatE can model any combination of scaling and rotation per dimension, giving it the asymmetric modeling power you need while keeping the parameter count linear rather than quadratic."
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-4"
                },
                "children": "(2/7/2026, 6:44:45 AM)"
              }
            ]
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "❓ Why does TransE fail on symmetric relations?",
              "defaultOpen": false
            },
            "children": [
              {
                "type": "p",
                "children": "TransE requires h + r = t. For a symmetric relation like 'married_to', we need BOTH h + r = t AND t + r = h to hold."
              },
              {
                "type": "p",
                "children": "Adding these: (h + t) + 2r = (h + t), which forces r = 0."
              },
              {
                "type": "p",
                "children": "So TransE learns r = 0 for all symmetric relations — entities connected by symmetric relations become indistinguishable!"
              },
              {
                "type": "p",
                "children": "RotatE solves this: symmetric relations are 180° rotations (r = -1). Rotating twice returns to start: (-1)×(-1) = 1."
              }
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "success"
            },
            "children": "RotatE handles ALL THREE patterns: symmetry, antisymmetry, inversion, AND composition. This is the main contribution."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "2. Three Relation Patterns"
        },
        "children": [
          {
            "type": "p",
            "children": "The paper identifies three critical patterns that any good model should handle:"
          },
          {
            "type": "h3",
            "children": "Pattern 1: Symmetry / Antisymmetry"
          },
          {
            "type": "p",
            "children": "Symmetric: If r(x,y) then r(y,x). Example: married_to, similar_to"
          },
          {
            "type": "p",
            "children": "Antisymmetric: If r(x,y) then NOT r(y,x). Example: parent_of, older_than"
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "RotatE solution: A relation r is symmetric iff r = ±1 (rotation by 0° or 180°). For any other angle, it's antisymmetric."
          },
          {
            "type": "h3",
            "children": "Pattern 2: Inversion"
          },
          {
            "type": "p",
            "children": "r₁ is inverse of r₂ if: r₂(x,y) implies r₁(y,x). Example: hypernym/hyponym, parent/child"
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "RotatE solution: r₂ = r̄₁ (complex conjugate). Rotating by θ then by -θ gets you back to start."
          },
          {
            "type": "h3",
            "children": "Pattern 3: Composition"
          },
          {
            "type": "p",
            "children": "r₃ = r₁ ∘ r₂ if: r₁(x,y) AND r₂(y,z) implies r₃(x,z). Example: grandfather = father ∘ father"
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "RotatE solution: r₃ = r₁ ⊙ r₂. Rotation angles ADD: θ₃ = θ₁ + θ₂. This is why complex numbers are perfect!"
          },
          {
            "type": "Example",
            "props": {
              "title": "Composition Example"
            },
            "children": [
              {
                "type": "p",
                "children": "father = rotation by 30°"
              },
              {
                "type": "p",
                "children": "grandfather = father ∘ father = rotation by 60°"
              },
              {
                "type": "p",
                "children": "great-grandfather = rotation by 90°"
              },
              {
                "type": "p",
                "children": "The angles compose naturally via complex multiplication!"
              }
            ]
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "3. The RotatE Model"
        },
        "children": [
          {
            "type": "h3",
            "children": "Core Equation"
          },
          {
            "type": "p",
            "children": "For a triple (h, r, t), we want:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "t = h ⊙ r\n\nwhere:\n  h, t ∈ ℂᵏ  (k-dimensional complex vectors)\n  r ∈ ℂᵏ with |rᵢ| = 1 (unit complex = rotation)\n  ⊙ = element-wise (Hadamard) product"
          },
          {
            "type": "p",
            "children": "For each dimension i:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "tᵢ = hᵢ × rᵢ\n\nSince |rᵢ| = 1, we can write rᵢ = e^(iθᵢ)\nThis rotates hᵢ by angle θᵢ in the complex plane"
          },
          {
            "type": "h3",
            "children": "Distance (Scoring) Function"
          },
          {
            "type": "p",
            "children": "To score a triple, RotatE measures how close h⊙r is to t:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "d(h, r, t) = ||h ⊙ r - t||\n\nLower distance = better match\nA perfect triple has distance 0"
          },
          {
            "type": "h3",
            "children": "Training: Negative Sampling"
          },
          {
            "type": "p",
            "children": "The model learns by contrasting true triples with corrupted (false) triples:"
          },
          {
            "type": "Code",
            "props": {
              "language": "python"
            },
            "children": "# Loss function:\nL = -log(σ(γ - d(h,r,t)))           # True triple: distance < margin γ\n  - Σ log(σ(d(h',r,t') - γ))        # False triples: distance > margin γ\n\n# σ = sigmoid, γ = margin (hyperparameter)"
          },
          {
            "type": "Callout",
            "props": {
              "type": "tip"
            },
            "children": "Self-adversarial negative sampling: Sample harder negatives based on current embeddings. Triples that currently score well (but are false) are weighted more heavily."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "4. Why Each Pattern Works"
        },
        "children": [
          {
            "type": "h3",
            "children": "Symmetry: r = ±1"
          },
          {
            "type": "p",
            "children": "If r(x,y) and r(y,x) both hold, then:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "y = x ⊙ r  (from first triple)\nx = y ⊙ r  (from second triple)\n\nSubstituting: x = (x ⊙ r) ⊙ r = x ⊙ r²\n\nThis requires r² = 1, so r = ±1\n\nr = +1: rotation by 0° (identity)\nr = -1: rotation by 180°"
          },
          {
            "type": "h3",
            "children": "Inversion: r₂ = r̄₁"
          },
          {
            "type": "p",
            "children": "If r₁(x,y) and r₂(y,x), then r₂ = r̄₁ (complex conjugate):"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "y = x ⊙ r₁  →  x = y ⊙ r₂\n\nFor this to work: r₁ ⊙ r₂ = 1\n\nSo r₂ = 1/r₁ = r̄₁ (conjugate, since |r₁| = 1)"
          },
          {
            "type": "h3",
            "children": "Composition: r₃ = r₁ ⊙ r₂"
          },
          {
            "type": "p",
            "children": "If r₁(x,y) and r₂(y,z), then r₃(x,z) where r₃ = r₁ ⊙ r₂:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "y = x ⊙ r₁\nz = y ⊙ r₂ = (x ⊙ r₁) ⊙ r₂ = x ⊙ (r₁ ⊙ r₂)\n\nSo z = x ⊙ r₃ where r₃ = r₁ ⊙ r₂\n\nIn terms of angles: θ₃ = θ₁ + θ₂"
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "5. Comparison to Other Models"
        },
        "children": [
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Model",
                "Score Function",
                "Symmetry",
                "Antisymmetry",
                "Inversion",
                "Composition"
              ],
              "rows": [
                [
                  "TransE",
                  "||h + r - t||",
                  "❌",
                  "✅",
                  "✅",
                  "✅"
                ],
                [
                  "DistMult",
                  "⟨h, r, t⟩",
                  "✅",
                  "❌",
                  "❌",
                  "❌"
                ],
                [
                  "ComplEx",
                  "Re(⟨h, r, t̄⟩)",
                  "✅",
                  "✅",
                  "✅",
                  "❌"
                ],
                [
                  "RotatE",
                  "||h ⊙ r - t||",
                  "✅",
                  "✅",
                  "✅",
                  "✅"
                ]
              ]
            }
          },
          {
            "type": "Callout",
            "props": {
              "type": "success"
            },
            "children": "RotatE is the ONLY model that handles all four patterns. This is why it achieves state-of-the-art on benchmarks."
          },
          {
            "type": "h3",
            "children": "Why TransE Fails on Symmetry"
          },
          {
            "type": "p",
            "children": "TransE uses: t = h + r. For symmetric relations where h→t and t→h both hold:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "t = h + r  and  h = t + r\n\nSubtracting: 0 = 2r, so r = 0\n\nAll symmetric relations collapse to r = 0!\nEntities with symmetric relations get pushed together."
          },
          {
            "type": "p",
            "children": "RotatE avoids this because rotation by 180° (r = -1) is a valid non-zero representation."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "6. Experimental Results"
        },
        "children": [
          {
            "type": "h3",
            "children": "Benchmark Datasets"
          },
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Dataset",
                "Entities",
                "Relations",
                "Main Patterns"
              ],
              "rows": [
                [
                  "FB15k",
                  "14,951",
                  "1,345",
                  "Symmetry, Inversion"
                ],
                [
                  "WN18",
                  "40,943",
                  "18",
                  "Symmetry, Inversion"
                ],
                [
                  "FB15k-237",
                  "14,541",
                  "237",
                  "Composition (inverse relations removed)"
                ],
                [
                  "WN18RR",
                  "40,943",
                  "11",
                  "Symmetry, Composition"
                ]
              ]
            }
          },
          {
            "type": "h3",
            "children": "Key Results"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "RotatE achieves state-of-the-art on ALL benchmarks"
              },
              {
                "type": "li",
                "children": "Especially strong on FB15k-237 and WN18RR (composition-heavy)"
              },
              {
                "type": "li",
                "children": "pRotatE (phase-only variant) also works but worse on composition"
              },
              {
                "type": "li",
                "children": "Self-adversarial negative sampling helps significantly"
              }
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "The modulus of entity embeddings (not just phase) is critical for composition patterns. This is why full RotatE beats pRotatE."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "7. Connection to Schankian Operators"
        },
        "children": [
          {
            "type": "Callout",
            "props": {
              "type": "warning"
            },
            "children": "This section connects RotatE to your research on learned Schankian operators."
          },
          {
            "type": "h3",
            "children": "What We Borrow from RotatE"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "Complex vector embeddings for entities"
              },
              {
                "type": "li",
                "children": "Relations (operators) as rotations"
              },
              {
                "type": "li",
                "children": "Margin-based ranking loss"
              },
              {
                "type": "li",
                "children": "The scoring function ||h ⊙ r - t||"
              }
            ]
          },
          {
            "type": "h3",
            "children": "How We Extend RotatE"
          },
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Aspect",
                "RotatE",
                "Schankian Operators"
              ],
              "rows": [
                [
                  "Domain",
                  "Static knowledge graphs",
                  "Event semantics / narratives"
                ],
                [
                  "Triples",
                  "(entity, relation, entity)",
                  "(agent, operator, patient)"
                ],
                [
                  "Goal",
                  "Link prediction",
                  "Learn semantic primitives"
                ],
                [
                  "Relations",
                  "Pre-defined in KG",
                  "Discovered from data"
                ],
                [
                  "Asymmetry",
                  "Some relations",
                  "ALL operators (agent ≠ patient)"
                ]
              ]
            }
          },
          {
            "type": "h3",
            "children": "Key Insight"
          },
          {
            "type": "p",
            "children": "RotatE proves that rotation-based operators can capture complex relational patterns. We apply this to EVENT semantics:"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "'cop shot frank' → HARM(cop, frank)"
              },
              {
                "type": "li",
                "children": "'frank shot cop' → HARM(frank, cop) — DIFFERENT!"
              },
              {
                "type": "li",
                "children": "Non-commutativity is built into the rotation framework"
              }
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "tip"
            },
            "children": "Our Phase 1 experiment (88% operator recovery) validates that RotatE's approach works for learning Schankian-style operators from data."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "8. Implementation Details"
        },
        "children": [
          {
            "type": "h3",
            "children": "Hyperparameters"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "Embedding dimension k: 125, 250, 500, or 1000"
              },
              {
                "type": "li",
                "children": "Batch size: 512, 1024, or 2048"
              },
              {
                "type": "li",
                "children": "Margin γ: 3 to 30"
              },
              {
                "type": "li",
                "children": "Self-adversarial temperature α: 0.5 or 1.0"
              },
              {
                "type": "li",
                "children": "Optimizer: Adam"
              },
              {
                "type": "li",
                "children": "No regularization (margin prevents overfitting)"
              }
            ]
          },
          {
            "type": "h3",
            "children": "Initialization"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "Entity embeddings: uniform random (real + imaginary parts)"
              },
              {
                "type": "li",
                "children": "Relation phases: uniform in [0, 2π]"
              }
            ]
          },
          {
            "type": "h3",
            "children": "Code"
          },
          {
            "type": "p",
            "children": "Official implementation: github.com/DeepGraphLearning/KnowledgeGraphEmbedding"
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "Key Takeaways"
        },
        "children": [
          {
            "type": "ol",
            "children": [
              {
                "type": "li",
                "children": "Relations as rotations: t = h ⊙ r where |r| = 1"
              },
              {
                "type": "li",
                "children": "Handles ALL patterns: symmetry, antisymmetry, inversion, composition"
              },
              {
                "type": "li",
                "children": "Composition = angle addition: θ₃ = θ₁ + θ₂"
              },
              {
                "type": "li",
                "children": "Self-adversarial sampling improves training"
              },
              {
                "type": "li",
                "children": "State-of-the-art on all major KG benchmarks"
              },
              {
                "type": "li",
                "children": "Foundation for our Schankian operator research"
              }
            ]
          }
        ]
      }
    ]
  }
}