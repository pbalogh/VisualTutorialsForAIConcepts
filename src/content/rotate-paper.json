{
  "id": "rotate-paper",
  "title": "RotatE Paper: Annotated Tutorial",
  "subtitle": "Knowledge Graph Embedding by Relational Rotation in Complex Space ‚Äî Sun et al., ICLR 2019",
  "readTime": "45 min",
  "state": {},
  "content": {
    "type": "Fragment",
    "children": [
      {
        "type": "Callout",
        "props": {
          "type": "info"
        },
        "children": "This is an annotated, interactive version of the RotatE paper. Original: arxiv.org/abs/1902.10197. Annotations explain concepts in plain English and connect to Schankian operator research."
      },
      {
        "type": "Section",
        "props": {
          "title": "1. The Big Picture"
        },
        "children": [
          {
            "type": "h3",
            "children": "What Problem Does RotatE Solve?"
          },
          {
            "type": "p",
            "children": "Knowledge graphs store facts as triples: (head, relation, tail). For example: (Obama, bornIn, Hawaii). The problem: knowledge graphs are always incomplete. Can we predict missing links?"
          },
          {
            "type": "Example",
            "props": {
              "title": "Link Prediction"
            },
            "children": [
              {
                "type": "p",
                "children": "Given: (Obama, bornIn, ?)"
              },
              {
                "type": "p",
                "children": "Predict: Hawaii"
              },
              {
                "type": "p",
                "children": "Or given: (?, presidentOf, USA)"
              },
              {
                "type": "p",
                "children": "Predict: Obama, Biden, Trump, ..."
              }
            ]
          },
          {
            "type": "h3",
            "children": "The Key Insight"
          },
          {
            "type": "Callout",
            "props": {
              "type": "tip"
            },
            "children": "RotatE models relations as ROTATIONS in complex vector space. If you rotate the head entity by the relation angle, you should arrive at the tail entity."
          },
          {
            "type": "p",
            "children": [
              "Mathematically: t = h ‚äô r, where ‚äô is element-wise multiplication of complex numbers, and |r| = 1 (unit",
              {
                "type": "FootnoteRef",
                "props": {
                  "id": "source-ann-1770464855396-1umwkg",
                  "targetId": "ann-1770464855396-1umwkg",
                  "type": "ask"
                }
              },
              " complex number = rotation)."
            ]
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "‚ùì Q: Can we follow this excellent visualization with a similar one that uses non-unit complex numbers so we can show how magnitude as well as angle can be affected?",
              "defaultOpen": true,
              "id": "ann-1770464855396-1umwkg",
              "sourceId": "source-ann-1770464855396-1umwkg"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info"
                },
                "children": [
                  {
                    "type": "em",
                    "children": "About \"unit\""
                  }
                ]
              },
              {
                "type": "p",
                "children": "Absolutely! Using non-unit complex numbers would demonstrate how RotatE could theoretically perform both rotation AND scaling simultaneously."
              },
              {
                "type": "p",
                "children": "If we allowed |r| ‚â† 1, then r would have both an angle (for rotation) and a magnitude (for scaling). For example, if r = 2e^(iœÄ/4), it would rotate the head entity by 45¬∞ AND double its distance from the origin. This would mean the tail entity could end up at any distance from the head, not just on the unit circle around it."
              },
              {
                "type": "p",
                "children": [
                  "However, RotatE specifically constrains |r| = 1",
                  {
                    "type": "FootnoteRef",
                    "props": {
                      "id": "source-ann-1770465082460-5j1kke",
                      "targetId": "ann-1770465082460-5j1kke",
                      "type": "footnote"
                    }
                  },
                  " because knowledge graph relations should preserve the \"semantic space\" - entities shouldn't drift arbitrarily far apart just because they're connected by a relation. The unit constraint ensures that relations are pure rotations, maintaining consistent geometric structure where similar entities cluster together."
                ]
              },
              {
                "type": "p",
                "children": "You could visualize this by showing the same head-relation-tail transformation with r = 2e^(iœÄ/3) versus r = e^(iœÄ/3), demonstrating how the non-unit version distorts the semantic space by stretching entity distances, which would likely hurt the model's ability to capture meaningful patterns in the knowledge graph."
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-4"
                },
                "children": "(2/7/2026, 6:47:26 AM)"
              }
            ]
          },
          {
            "type": "Footnote",
            "props": {
              "id": "ann-1770465082460-5j1kke",
              "reference": "However, RotatE specifically c",
              "userNote": "This kinda contradicts something you said elsewhere, when I asked about \"what if the target has one or more dimensions in which its magnitude has changed drastically compared to all the other dimensions? Don't you need some way to amplify/reduce each dimension individually?\"",
              "sourceId": "source-ann-1770465082460-5j1kke"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info",
                  "className": "mb-3 text-sm"
                },
                "children": [
                  {
                    "type": "strong",
                    "children": "üìù Your note: "
                  },
                  "This kinda contradicts something you said elsewhere, when I asked about \"what if the target has one or more dimensions in which its magnitude has changed drastically compared to all the other dimensions? Don't you need some way to amplify/reduce each dimension individually?\""
                ]
              },
              {
                "type": "p",
                "children": "Great observation! You've identified a fundamental tension in RotatE's design. You're absolutely right that constraining |r| = 1 seems to conflict with the need for dimension-wise scaling that we discussed earlier."
              },
              {
                "type": "p",
                "children": "Here's what's actually happening: RotatE makes a deliberate trade-off. By forcing relations to be pure rotations (unit magnitude), it sacrifices some representational flexibility in favor of geometric consistency. This means RotatE can't directly model relations that should amplify or dampen specific dimensions - like a \"specialization\" relation that might increase precision in some semantic dimensions while reducing scope in others. Instead, RotatE relies on the rotation angles themselves to capture these nuanced transformations. A relation might rotate different dimensions by different amounts, effectively redistributing the entity's \"semantic energy\" across dimensions rather than changing its overall magnitude."
              },
              {
                "type": "p",
                "children": "This constraint is both RotatE's strength and limitation. It ensures that the embedding space maintains nice geometric properties - entities don't drift arbitrarily far from their neighborhoods, and similar entities stay clustered. But as you noted, it means RotatE might struggle with relations that intuitively should involve magnitude changes. Later models like RotatE3D and others try to address this by introducing additional parameters while still maintaining some geometric structure."
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-2"
                },
                "children": "2/7/2026, 6:51:15 AM"
              }
            ]
          },
          {
            "type": "ComplexRotationViz",
            "props": {
              "initialAngle": 45
            }
          },
          {
            "type": "h3",
            "children": "Why Rotations?"
          },
          {
            "type": "p",
            "children": "Previous models had limitations:"
          },
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Model",
                "Approach",
                "Can't Handle"
              ],
              "rows": [
                [
                  "TransE",
                  "h + r ‚âà t (translation)",
                  "Symmetric relations (married_to)"
                ],
                [
                  "DistMult",
                  "‚ü®h, r, t‚ü© (dot product)",
                  "Antisymmetric relations (parent_of)"
                ],
                [
                  "ComplEx",
                  "Re(‚ü®h, r, tÃÑ‚ü©)",
                  "Composition (grandfather = father ‚àò father)"
                ]
              ],
              "highlightRows": [
                1,
                2
              ],
              "highlightId": "ann-1770465186049-e7pynq"
            }
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "‚ùì Q: Please flesh this out like you did with TransE",
              "defaultOpen": true,
              "id": "ann-1770465186049-e7pynq",
              "sourceId": "source-ann-1770465186049-e7pynq"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info"
                },
                "children": [
                  {
                    "type": "em",
                    "children": "About \"ComplEx\""
                  }
                ]
              },
              {
                "type": "p",
                "children": "ComplEx extends the embedding approach by moving from real-valued vectors to complex-valued vectors, where each embedding has both real and imaginary components. This allows it to handle asymmetric relations more naturally than TransE."
              },
              {
                "type": "p",
                "children": "The key insight is that complex multiplication can encode different types of transformations. Where TransE uses simple addition (h + r ‚âà t), ComplEx uses complex multiplication and conjugation. For a relation r with complex embedding, the scoring function becomes Re(‚ü®h, r, tÃÑ‚ü©), where tÃÑ is the complex conjugate of t and ‚ü®¬∑,¬∑,¬∑‚ü© is a three-way inner product."
              },
              {
                "type": "p",
                "children": "This complex arithmetic naturally handles asymmetric relations like \"parent_of\" because complex conjugation breaks symmetry - if (h, r, t) has a high score, (t, r, h) won't automatically have the same score. The real part of the result gives the final compatibility score, while the imaginary components help encode directional relationships that TransE struggles with."
              },
              {
                "type": "p",
                "children": "Think of it as upgrading from a 2D coordinate system (TransE's real vectors) to a 2D plane where you can also rotate and flip vectors (ComplEx's complex space), giving much richer representational power for modeling the diverse patterns found in knowledge graphs."
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-4"
                },
                "children": "(2/7/2026, 6:52:55 AM)"
              }
            ]
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "‚ùì Q: Can you flesh this out the way you did with TransE?",
              "defaultOpen": true,
              "id": "ann-1770464450203-oj2nkl",
              "sourceId": "source-ann-1770464450203-oj2nkl"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info"
                },
                "children": [
                  {
                    "type": "em",
                    "children": "About \"DistMult\""
                  }
                ]
              },
              {
                "type": "p",
                "children": "DistMult is another fundamental knowledge graph embedding method that takes a very different approach from TransE. While TransE models relationships as translations in vector space (h + r ‚âà t), DistMult models them as element-wise multiplications."
              },
              {
                "type": "p",
                "children": "In DistMult, entities are represented as vectors and relations are represented as diagonal matrices (or equivalently, vectors). The scoring function is simply the dot product: score(h,r,t) = h^T diag(r) t = Œ£·µ¢ h·µ¢ √ó r·µ¢ √ó t·µ¢. This means DistMult captures how well entities \"match\" through a relation by measuring their component-wise compatibility."
              },
              {
                "type": "p",
                "children": [
                  "However, DistMult has a critical limitation that RotatE aims to address: it's symmetric by design. Since multiplication is commutative (h √ó r √ó t = t √ó r √ó h), DistMult cannot distinguish",
                  {
                    "type": "FootnoteRef",
                    "props": {
                      "id": "source-ann-1770464568269-xgf8h5",
                      "targetId": "ann-1770464568269-xgf8h5",
                      "type": "ask"
                    }
                  },
                  " between (head, relation, tail) and (tail, relation, head). This makes it impossible to model asymmetric relations like \"parent_of\" - if John is the parent of Mary, DistMult would incorrectly suggest Mary is also the parent of John."
                ]
              },
              {
                "type": "p",
                "children": "This symmetry constraint is exactly what motivated the development of more sophisticated models like RotatE, which uses complex rotations to capture both symmetric patterns (like DistMult's strengths) and asymmetric patterns (addressing DistMult's key weakness) in a unified framework."
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-4"
                },
                "children": "(2/7/2026, 6:40:41 AM)"
              }
            ]
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "‚ùì Q: Isn't this just the inevitable result of using a diagonal matrix? Why didn't they use a more robust, freeform matrix?",
              "defaultOpen": true,
              "id": "ann-1770464568269-xgf8h5",
              "sourceId": "source-ann-1770464568269-xgf8h5"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info"
                },
                "children": [
                  {
                    "type": "em",
                    "children": "About \"DistMult cannot distinguish\""
                  }
                ]
              },
              {
                "type": "p",
                "children": "You're absolutely right that this is a consequence of DistMult's design choice to use diagonal matrices! The designers of DistMult deliberately chose this constrained approach for computational efficiency and to reduce overfitting, not because they couldn't think of using full matrices."
              },
              {
                "type": "p",
                "children": "A full matrix would indeed be more expressive, but it comes with major trade-offs. With diagonal matrices, DistMult only needs to learn one parameter per dimension for each relation, making it fast and less prone to memorizing the training data. A full matrix would require learning d¬≤ parameters per relation (where d is the embedding dimension), making it computationally expensive and more likely to overfit, especially when training data is limited."
              },
              {
                "type": "p",
                "children": [
                  "The real insight of the RotatE paper isn't just pointing out this limitation - it's showing how to get the best of both worlds. RotatE achieves the asymmetry that full matrices could provide, but does so with the same parameter efficiency as diagonal matrices. Instead of using more parameters, it uses complex numbers and rotation operations to elegantly encode directional relationships. This is why RotatE is considered an advancement: it solves the asymmetry problem",
                  {
                    "type": "FootnoteRef",
                    "props": {
                      "id": "source-ann-1770464691587-75xkbd",
                      "targetId": "ann-1770464691587-75xkbd",
                      "type": "ask"
                    }
                  },
                  " without sacrificing the computational benefits that made DistMult attractive in the first place."
                ]
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-4"
                },
                "children": "(2/7/2026, 6:42:38 AM)"
              }
            ]
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "‚ùì Q: What worries me, though, is that rotating a vector in multiple dimensions will only work if the target vector has the same shape across all dimensions, no? If the target is much larger or smaller in one particular dimension, how can rotation work at getting us to it?",
              "defaultOpen": true,
              "id": "ann-1770464691587-75xkbd",
              "sourceId": "source-ann-1770464691587-75xkbd"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info"
                },
                "children": [
                  {
                    "type": "em",
                    "children": "About \"solves the asymmetry problem\""
                  }
                ]
              },
              {
                "type": "p",
                "children": "You're thinking about rotation too literally - like rotating a physical object where the shape must be preserved. In RotatE, \"rotation\" is actually element-wise multiplication by complex numbers, which allows both rotation AND scaling simultaneously."
              },
              {
                "type": "p",
                "children": "Here's what actually happens: each dimension of the relation embedding is a complex number with both magnitude and phase. When you multiply the head entity by this complex relation, you're not just rotating - you're rotating each dimension by a potentially different angle AND scaling it by a potentially different amount. The magnitude of each complex number controls the scaling, while the phase controls the rotation."
              },
              {
                "type": "p",
                "children": "So if your target vector needs to be much larger in dimension 3 but smaller in dimension 1, the relation embedding can have a large magnitude in dimension 3 (strong scaling up) and small magnitude in dimension 1 (scaling down), each with their own rotation angles. This is why RotatE can capture the same expressiveness as full matrix transformations - it's not constrained to rigid rotations that preserve vector length and shape."
              },
              {
                "type": "p",
                "children": "This element-wise approach means RotatE can model any combination of scaling and rotation per dimension, giving it the asymmetric modeling power you need while keeping the parameter count linear rather than quadratic."
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-4"
                },
                "children": "(2/7/2026, 6:44:45 AM)"
              }
            ]
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "‚ùì Why does TransE fail on symmetric relations?",
              "defaultOpen": false
            },
            "children": [
              {
                "type": "p",
                "children": "TransE requires h + r = t. For a symmetric relation like 'married_to', we need BOTH h + r = t AND t + r = h to hold."
              },
              {
                "type": "p",
                "children": "Adding these: (h + t) + 2r = (h + t), which forces r = 0."
              },
              {
                "type": "p",
                "children": "So TransE learns r = 0 for all symmetric relations ‚Äî entities connected by symmetric relations become indistinguishable!"
              },
              {
                "type": "p",
                "children": "RotatE solves this: symmetric relations are 180¬∞ rotations (r = -1). Rotating twice returns to start: (-1)√ó(-1) = 1."
              }
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "success"
            },
            "children": "RotatE handles ALL THREE patterns: symmetry, antisymmetry, inversion, AND composition. This is the main contribution."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "2. Three Relation Patterns"
        },
        "children": [
          {
            "type": "p",
            "children": "The paper identifies three critical patterns that any good model should handle:"
          },
          {
            "type": "h3",
            "children": "Pattern 1: Symmetry / Antisymmetry"
          },
          {
            "type": "p",
            "children": "Symmetric: If r(x,y) then r(y,x). Example: married_to, similar_to"
          },
          {
            "type": "p",
            "children": "Antisymmetric: If r(x,y) then NOT r(y,x). Example: parent_of, older_than"
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "RotatE solution: A relation r is symmetric iff r = ¬±1 (rotation by 0¬∞ or 180¬∞). For any other angle, it's antisymmetric."
          },
          {
            "type": "h3",
            "children": "Pattern 2: Inversion"
          },
          {
            "type": "p",
            "children": [
              "r‚ÇÅ is inverse of r‚ÇÇ if: r‚ÇÇ(x,y) implies r‚ÇÅ(y,x). Example: hypernym/hyponym",
              {
                "type": "FootnoteRef",
                "props": {
                  "id": "source-ann-1770465292732-ywfsx1",
                  "targetId": "ann-1770465292732-ywfsx1",
                  "type": "explain"
                }
              },
              ", parent/child"
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "info",
              "id": "ann-1770465292732-ywfsx1",
              "sourceId": "source-ann-1770465292732-ywfsx1"
            },
            "children": [
              {
                "type": "strong",
                "children": "üí° \"hypernym/hyponym\":"
              },
              " ",
              "In this context, hypernym/hyponym demonstrates the inverse relationship pattern that RotatE needs to model. If \"animal\" is a hypernym of \"dog\" (meaning animal is the broader category), then \"dog\" is automatically a hyponym of \"animal\" (the more specific term) - they're inverse relations where the entity positions are swapped. This is exactly the kind of relational reasoning challenge that RotatE's rotation-based approach is designed to handle elegantly.",
              " ",
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs"
                },
                "children": "(2/7/2026, 6:54:48 AM)"
              }
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "RotatE solution: r‚ÇÇ = rÃÑ‚ÇÅ (complex conjugate). Rotating by Œ∏ then by -Œ∏ gets you back to start."
          },
          {
            "type": "h3",
            "children": "Pattern 3: Composition"
          },
          {
            "type": "p",
            "children": "r‚ÇÉ = r‚ÇÅ ‚àò r‚ÇÇ if: r‚ÇÅ(x,y) AND r‚ÇÇ(y,z) implies r‚ÇÉ(x,z). Example: grandfather = father ‚àò father"
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "RotatE solution: r‚ÇÉ = r‚ÇÅ ‚äô r‚ÇÇ. Rotation angles ADD: Œ∏‚ÇÉ = Œ∏‚ÇÅ + Œ∏‚ÇÇ. This is why complex numbers are perfect!"
          },
          {
            "type": "Example",
            "props": {
              "title": "Composition Example"
            },
            "children": [
              {
                "type": "p",
                "children": "father = rotation by 30¬∞"
              },
              {
                "type": "p",
                "children": "grandfather = father ‚àò father = rotation by 60¬∞"
              },
              {
                "type": "p",
                "children": "great-grandfather = rotation by 90¬∞"
              },
              {
                "type": "p",
                "children": "The angles compose naturally via complex multiplication!"
              }
            ]
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "3. The RotatE Model"
        },
        "children": [
          {
            "type": "h3",
            "children": "Core Equation"
          },
          {
            "type": "p",
            "children": "For a triple (h, r, t), we want:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "t = h ‚äô r\n\nwhere:\n  h, t ‚àà ‚ÑÇ·µè  (k-dimensional complex vectors)\n  r ‚àà ‚ÑÇ·µè with |r·µ¢| = 1 (unit complex = rotation)\n  ‚äô = element-wise (Hadamard) product"
          },
          {
            "type": "p",
            "children": "For each dimension i:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "t·µ¢ = h·µ¢ √ó r·µ¢\n\nSince |r·µ¢| = 1, we can write r·µ¢ = e^(iŒ∏·µ¢)\nThis rotates h·µ¢ by angle Œ∏·µ¢ in the complex plane"
          },
          {
            "type": "h3",
            "children": "Distance (Scoring) Function"
          },
          {
            "type": "p",
            "children": "To score a triple, RotatE measures how close h‚äôr is to t:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "d(h, r, t) = ||h ‚äô r - t||\n\nLower distance = better match\nA perfect triple has distance 0"
          },
          {
            "type": "h3",
            "children": "Training: Negative Sampling"
          },
          {
            "type": "p",
            "children": "The model learns by contrasting true triples with corrupted (false) triples:"
          },
          {
            "type": "Code",
            "props": {
              "language": "python"
            },
            "children": "# Loss function:\nL = -log(œÉ(Œ≥ - d(h,r,t)))           # True triple: distance < margin Œ≥\n  - Œ£ log(œÉ(d(h',r,t') - Œ≥))        # False triples: distance > margin Œ≥\n\n# œÉ = sigmoid, Œ≥ = margin (hyperparameter)"
          },
          {
            "type": "Callout",
            "props": {
              "type": "tip"
            },
            "children": "Self-adversarial negative sampling: Sample harder negatives based on current embeddings. Triples that currently score well (but are false) are weighted more heavily."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "4. Why Each Pattern Works"
        },
        "children": [
          {
            "type": "h3",
            "children": "Symmetry: r = ¬±1"
          },
          {
            "type": "p",
            "children": "If r(x,y) and r(y,x) both hold, then:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "y = x ‚äô r  (from first triple)\nx = y ‚äô r  (from second triple)\n\nSubstituting: x = (x ‚äô r) ‚äô r = x ‚äô r¬≤\n\nThis requires r¬≤ = 1, so r = ¬±1\n\nr = +1: rotation by 0¬∞ (identity)\nr = -1: rotation by 180¬∞"
          },
          {
            "type": "h3",
            "children": "Inversion: r‚ÇÇ = rÃÑ‚ÇÅ"
          },
          {
            "type": "p",
            "children": "If r‚ÇÅ(x,y) and r‚ÇÇ(y,x), then r‚ÇÇ = rÃÑ‚ÇÅ (complex conjugate):"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "y = x ‚äô r‚ÇÅ  ‚Üí  x = y ‚äô r‚ÇÇ\n\nFor this to work: r‚ÇÅ ‚äô r‚ÇÇ = 1\n\nSo r‚ÇÇ = 1/r‚ÇÅ = rÃÑ‚ÇÅ (conjugate, since |r‚ÇÅ| = 1)"
          },
          {
            "type": "h3",
            "children": "Composition: r‚ÇÉ = r‚ÇÅ ‚äô r‚ÇÇ"
          },
          {
            "type": "p",
            "children": "If r‚ÇÅ(x,y) and r‚ÇÇ(y,z), then r‚ÇÉ(x,z) where r‚ÇÉ = r‚ÇÅ ‚äô r‚ÇÇ:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "y = x ‚äô r‚ÇÅ\nz = y ‚äô r‚ÇÇ = (x ‚äô r‚ÇÅ) ‚äô r‚ÇÇ = x ‚äô (r‚ÇÅ ‚äô r‚ÇÇ)\n\nSo z = x ‚äô r‚ÇÉ where r‚ÇÉ = r‚ÇÅ ‚äô r‚ÇÇ\n\nIn terms of angles: Œ∏‚ÇÉ = Œ∏‚ÇÅ + Œ∏‚ÇÇ"
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "5. Comparison to Other Models"
        },
        "children": [
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Model",
                "Score Function",
                "Symmetry",
                "Antisymmetry",
                "Inversion",
                "Composition"
              ],
              "rows": [
                [
                  "TransE",
                  "||h + r - t||",
                  "‚ùå",
                  "‚úÖ",
                  "‚úÖ",
                  "‚úÖ"
                ],
                [
                  "DistMult",
                  "‚ü®h, r, t‚ü©",
                  "‚úÖ",
                  "‚ùå",
                  "‚ùå",
                  "‚ùå"
                ],
                [
                  "ComplEx",
                  "Re(‚ü®h, r, tÃÑ‚ü©)",
                  "‚úÖ",
                  "‚úÖ",
                  "‚úÖ",
                  "‚ùå"
                ],
                [
                  "RotatE",
                  "||h ‚äô r - t||",
                  "‚úÖ",
                  "‚úÖ",
                  "‚úÖ",
                  "‚úÖ"
                ]
              ]
            }
          },
          {
            "type": "Callout",
            "props": {
              "type": "success"
            },
            "children": "RotatE is the ONLY model that handles all four patterns. This is why it achieves state-of-the-art on benchmarks."
          },
          {
            "type": "h3",
            "children": "Why TransE Fails on Symmetry"
          },
          {
            "type": "p",
            "children": "TransE uses: t = h + r. For symmetric relations where h‚Üít and t‚Üíh both hold:"
          },
          {
            "type": "Code",
            "props": {
              "language": "text"
            },
            "children": "t = h + r  and  h = t + r\n\nSubtracting: 0 = 2r, so r = 0\n\nAll symmetric relations collapse to r = 0!\nEntities with symmetric relations get pushed together."
          },
          {
            "type": "p",
            "children": "RotatE avoids this because rotation by 180¬∞ (r = -1) is a valid non-zero representation."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "6. Experimental Results"
        },
        "children": [
          {
            "type": "h3",
            "children": "Benchmark Datasets"
          },
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Dataset",
                "Entities",
                "Relations",
                "Main Patterns"
              ],
              "rows": [
                [
                  "FB15k",
                  "14,951",
                  "1,345",
                  "Symmetry, Inversion"
                ],
                [
                  "WN18",
                  "40,943",
                  "18",
                  "Symmetry, Inversion"
                ],
                [
                  "FB15k-237",
                  "14,541",
                  "237",
                  "Composition (inverse relations removed)"
                ],
                [
                  "WN18RR",
                  "40,943",
                  "11",
                  "Symmetry, Composition"
                ]
              ]
            }
          },
          {
            "type": "h3",
            "children": "Key Results"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "RotatE achieves state-of-the-art on ALL benchmarks"
              },
              {
                "type": "li",
                "children": "Especially strong on FB15k-237 and WN18RR (composition-heavy)"
              },
              {
                "type": "li",
                "children": "pRotatE (phase-only variant) also works but worse on composition"
              },
              {
                "type": "li",
                "children": "Self-adversarial negative sampling helps significantly"
              }
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "info"
            },
            "children": "The modulus of entity embeddings (not just phase) is critical for composition patterns. This is why full RotatE beats pRotatE."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "7. Connection to Schankian Operators"
        },
        "children": [
          {
            "type": "Callout",
            "props": {
              "type": "warning"
            },
            "children": "This section connects RotatE to your research on learned Schankian operators."
          },
          {
            "type": "h3",
            "children": "What We Borrow from RotatE"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "Complex vector embeddings for entities"
              },
              {
                "type": "li",
                "children": "Relations (operators) as rotations"
              },
              {
                "type": "li",
                "children": "Margin-based ranking loss"
              },
              {
                "type": "li",
                "children": "The scoring function ||h ‚äô r - t||"
              }
            ]
          },
          {
            "type": "h3",
            "children": "How We Extend RotatE"
          },
          {
            "type": "ComparisonTable",
            "props": {
              "headers": [
                "Aspect",
                "RotatE",
                "Schankian Operators"
              ],
              "rows": [
                [
                  "Domain",
                  "Static knowledge graphs",
                  "Event semantics / narratives"
                ],
                [
                  "Triples",
                  "(entity, relation, entity)",
                  "(agent, operator, patient)"
                ],
                [
                  "Goal",
                  "Link prediction",
                  "Learn semantic primitives"
                ],
                [
                  "Relations",
                  "Pre-defined in KG",
                  "Discovered from data"
                ],
                [
                  "Asymmetry",
                  "Some relations",
                  "ALL operators (agent ‚â† patient)"
                ]
              ],
              "highlightRows": [
                1
              ],
              "highlightId": "ann-1770465567156-uiexu7"
            }
          },
          {
            "type": "Footnote",
            "props": {
              "id": "ann-1770465567156-uiexu7",
              "reference": "(agent, operator, patient)",
              "userNote": "Of course, there are *intransitive* verbs that change an entity's state as well! \"Frank died\"",
              "sourceId": "source-ann-1770465567156-uiexu7"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info",
                  "className": "mb-3 text-sm"
                },
                "children": [
                  {
                    "type": "strong",
                    "children": "üìù Your note: "
                  },
                  "Of course, there are *intransitive* verbs that change an entity's state as well! \"Frank died\""
                ]
              },
              {
                "type": "p",
                "children": "Great observation! You've identified a key limitation in the simple agent-operator-patient framework. Intransitive verbs like \"died,\" \"grew,\" \"melted,\" or \"arrived\" represent state changes that don't fit neatly into this three-role pattern since there's no clear patient being acted upon."
              },
              {
                "type": "p",
                "children": [
                  "This connects to a broader challenge in knowledge representation: real language is far more nuanced than any simple schema can capture. While \"Frank died\" changes Frank's state dramatically, it doesn't involve Frank acting on another entity. Similarly, \"The ice melted\" describes a transformation where the ice is both the thing changing and the thing being changed. These cases suggest that knowledge graphs need more sophisticated relation types beyond just agent-operator-patient triplets. In fact, this is one reason why modern knowledge graph embeddings like RotatE need to handle such diverse semantic relationships - they can't assume all facts follow the same structural pattern. The embedding space needs to be flexible enough to represent everything from transitive actions to intransitive state changes to static properties",
                  {
                    "type": "FootnoteRef",
                    "props": {
                      "id": "source-ann-1770465679467-lxdb6u",
                      "targetId": "ann-1770465679467-lxdb6u",
                      "type": "ask"
                    }
                  },
                  "."
                ]
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-2"
                },
                "children": "2/7/2026, 6:59:17 AM"
              }
            ]
          },
          {
            "type": "DeepDive",
            "props": {
              "title": "‚ùì Q: How does our approach handle this?",
              "defaultOpen": true,
              "id": "ann-1770465679467-lxdb6u",
              "sourceId": "source-ann-1770465679467-lxdb6u"
            },
            "children": [
              {
                "type": "Callout",
                "props": {
                  "type": "info"
                },
                "children": [
                  {
                    "type": "em",
                    "children": "About \"represent everything from transitive actions to intransitive state changes to static properties\""
                  }
                ]
              },
              {
                "type": "p",
                "children": "RotatE handles this diversity by treating all types of relationships‚Äîwhether transitive actions, intransitive changes, or static properties‚Äîas relations in the same geometric space. Instead of trying to force everything into agent-operator-patient structures, RotatE maps each relation type to a rotation in complex vector space."
              },
              {
                "type": "p",
                "children": "For example, a transitive action like \"Frank teaches math\" involves Frank acting on math as separate entities. But \"Frank died\" is modeled as a relation between Frank and a death state, while \"Frank is tall\" connects Frank to a height property. In RotatE's approach, \"teaches,\" \"died,\" and \"is_tall\" are all just different rotations‚Äîsome might be large rotations representing dramatic changes, others small rotations for subtle properties."
              },
              {
                "type": "p",
                "children": "This geometric flexibility means RotatE doesn't need to distinguish between these linguistic categories at the model level. Whether you're representing \"ice melts\" (where ice transforms) or \"teacher instructs student\" (where distinct entities interact), both become head entity + rotation = tail entity operations. The model learns appropriate rotation patterns for each relation type through training, naturally accommodating the full spectrum of real-world relationships without forcing them into rigid grammatical boxes."
              },
              {
                "type": "em",
                "props": {
                  "className": "text-gray-400 text-xs block mt-4"
                },
                "children": "(2/7/2026, 7:01:10 AM)"
              }
            ]
          },
          {
            "type": "h3",
            "children": "Key Insight"
          },
          {
            "type": "p",
            "children": "RotatE proves that rotation-based operators can capture complex relational patterns. We apply this to EVENT semantics:"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "'cop shot frank' ‚Üí HARM(cop, frank)"
              },
              {
                "type": "li",
                "children": "'frank shot cop' ‚Üí HARM(frank, cop) ‚Äî DIFFERENT!"
              },
              {
                "type": "li",
                "children": "Non-commutativity is built into the rotation framework"
              }
            ]
          },
          {
            "type": "Callout",
            "props": {
              "type": "tip"
            },
            "children": "Our Phase 1 experiment (88% operator recovery) validates that RotatE's approach works for learning Schankian-style operators from data."
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "8. Implementation Details"
        },
        "children": [
          {
            "type": "h3",
            "children": "Hyperparameters"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "Embedding dimension k: 125, 250, 500, or 1000"
              },
              {
                "type": "li",
                "children": "Batch size: 512, 1024, or 2048"
              },
              {
                "type": "li",
                "children": "Margin Œ≥: 3 to 30"
              },
              {
                "type": "li",
                "children": "Self-adversarial temperature Œ±: 0.5 or 1.0"
              },
              {
                "type": "li",
                "children": "Optimizer: Adam"
              },
              {
                "type": "li",
                "children": "No regularization (margin prevents overfitting)"
              }
            ]
          },
          {
            "type": "h3",
            "children": "Initialization"
          },
          {
            "type": "ul",
            "children": [
              {
                "type": "li",
                "children": "Entity embeddings: uniform random (real + imaginary parts)"
              },
              {
                "type": "li",
                "children": "Relation phases: uniform in [0, 2œÄ]"
              }
            ]
          },
          {
            "type": "h3",
            "children": "Code"
          },
          {
            "type": "p",
            "children": "Official implementation: github.com/DeepGraphLearning/KnowledgeGraphEmbedding"
          }
        ]
      },
      {
        "type": "Section",
        "props": {
          "title": "Key Takeaways"
        },
        "children": [
          {
            "type": "ol",
            "children": [
              {
                "type": "li",
                "children": "Relations as rotations: t = h ‚äô r where |r| = 1"
              },
              {
                "type": "li",
                "children": "Handles ALL patterns: symmetry, antisymmetry, inversion, composition"
              },
              {
                "type": "li",
                "children": "Composition = angle addition: Œ∏‚ÇÉ = Œ∏‚ÇÅ + Œ∏‚ÇÇ"
              },
              {
                "type": "li",
                "children": "Self-adversarial sampling improves training"
              },
              {
                "type": "li",
                "children": "State-of-the-art on all major KG benchmarks"
              },
              {
                "type": "li",
                "children": "Foundation for our Schankian operator research"
              }
            ]
          }
        ]
      }
    ]
  }
}