/**
 * Tutorial Annotation Server
 * 
 * Receives annotation requests from the tutorial UI,
 * calls AI to generate contextual content,
 * modifies the JSON, commits to Git, and returns updated JSON.
 * 
 * AI provider configured in: ai-config.js
 * 
 * Run: node annotation-server.js
 * Endpoint: POST http://localhost:5190/annotate
 */

import http from 'http'
import fs from 'fs/promises'
import path from 'path'
import { execSync } from 'child_process'
import { fileURLToPath } from 'url'
import { callAI, getAIInfo } from './ai-config.js'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const PORT = 5190
const CONTENT_DIR = path.join(__dirname, 'src/content')
const TUTORIALS_REPO = __dirname

/**
 * Parse JSON body from request
 */
function parseBody(req) {
  return new Promise((resolve, reject) => {
    let body = ''
    req.on('data', chunk => body += chunk)
    req.on('end', () => {
      try {
        resolve(body ? JSON.parse(body) : {})
      } catch (e) {
        reject(new Error('Invalid JSON'))
      }
    })
    req.on('error', reject)
  })
}

/**
 * Send JSON response with CORS headers
 */
function sendJson(res, statusCode, data) {
  res.writeHead(statusCode, {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type'
  })
  res.end(JSON.stringify(data))
}

/**
 * Generate annotation content using AI
 */
async function generateAnnotation(action, selectedText, context, tutorialTitle) {
  const timestamp = new Date().toLocaleString()
  
  // System prompt that emphasizes contextual understanding
  const systemPrompt = `You are helping create educational content for an interactive tutorial called "${tutorialTitle || 'Tutorial'}".

Your job is to generate explanations that help users understand concepts IN THE CONTEXT of what they're learning, not generic definitions.

Key principles:
- The user selected "${selectedText}" ‚Äî they likely know what these words mean individually
- What they want to know is: what does this mean HERE, in THIS tutorial's context?
- Be concise but insightful
- Reference other concepts from the tutorial when relevant
- Use concrete examples when helpful

Output format: Return ONLY the explanation text, no JSON, no formatting markers, no preamble.`

  try {
    if (action === 'explain') {
      const prompt = `The user is reading this passage:
"${context}"

They selected the phrase: "${selectedText}"

Write a brief (2-3 sentences) contextual explanation of what "${selectedText}" means in this specific context. Don't define the term generically ‚Äî explain its role and significance in what they're learning.`

      console.log('ü§ñ Calling AI for explanation...')
      const explanation = await callAI(systemPrompt, prompt)
      
      return {
        type: 'Callout',
        props: { type: 'info' },
        children: [
          {
            type: 'strong',
            children: `üí° "${selectedText}":`
          },
          ' ',
          explanation.trim(),
          ' ',
          {
            type: 'em',
            props: { className: 'text-gray-400 text-xs' },
            children: `(${timestamp})`
          }
        ]
      }
    }
    
    if (action === 'branch') {
      const prompt = `The user is reading this passage:
"${context}"

They want to go deeper on: "${selectedText}"

Write a focused deep-dive (3-4 paragraphs) that:
1. Explains why this concept matters in the current context
2. Provides a concrete example or analogy
3. Connects it to other concepts they might encounter
4. Gives them something actionable or a "now you can..." statement

Keep it educational and engaging, not dry. Do not use markdown formatting.`

      console.log('ü§ñ Calling AI for deep dive...')
      const deepDive = await callAI(systemPrompt, prompt)
      
      // Split into paragraphs
      const paragraphs = deepDive.trim().split('\n\n').filter(p => p.trim())
      
      return {
        type: 'DeepDive',
        props: { 
          title: `Deep Dive: ${selectedText}`,
          defaultOpen: true 
        },
        children: paragraphs.map(p => ({
          type: 'p',
          children: p.trim()
        }))
      }
    }
    
    return null
    
  } catch (error) {
    console.error('‚ùå AI error:', error.message)
    
    // Return error callout
    return {
      type: 'Callout',
      props: { type: 'warning' },
      children: [
        {
          type: 'strong',
          children: `‚ö†Ô∏è "${selectedText}":`
        },
        ' ',
        `AI generation failed: ${error.message}. Please try again.`,
        ' ',
        {
          type: 'em',
          props: { className: 'text-gray-400 text-xs' },
          children: `(${timestamp})`
        }
      ]
    }
  }
}

/**
 * Find and insert annotation into content tree
 */
function insertAnnotation(content, selectedText, annotation, action) {
  const newContent = JSON.parse(JSON.stringify(content))
  
  function searchAndInsert(node, parent, key) {
    if (typeof node === 'string') {
      if (node.includes(selectedText)) {
        return { found: true }
      }
      return { found: false }
    }
    
    if (Array.isArray(node)) {
      for (let i = 0; i < node.length; i++) {
        const result = searchAndInsert(node[i], node, i)
        if (result.found && !result.inserted) {
          node.splice(i + 1, 0, annotation)
          return { found: true, inserted: true }
        }
        if (result.inserted) return result
      }
      return { found: false }
    }
    
    if (node && typeof node === 'object') {
      if (node.children) {
        const result = searchAndInsert(node.children, node, 'children')
        if (result.found || result.inserted) return result
      }
      if (node.props?.children) {
        const result = searchAndInsert(node.props.children, node.props, 'children')
        if (result.found || result.inserted) return result
      }
    }
    
    return { found: false }
  }
  
  if (newContent.content?.children && Array.isArray(newContent.content.children)) {
    for (let i = 0; i < newContent.content.children.length; i++) {
      const section = newContent.content.children[i]
      const result = searchAndInsert(section, newContent.content.children, i)
      if (result.found && !result.inserted) {
        newContent.content.children.splice(i + 1, 0, {
          type: 'Section',
          props: { title: action === 'branch' ? '' : undefined },
          children: [annotation]
        })
        console.log(`‚úÖ Inserted annotation as new section after index ${i}`)
        return newContent
      }
      if (result.inserted) {
        console.log(`‚úÖ Inserted annotation inline`)
        return newContent
      }
    }
  }
  
  console.log(`‚ö†Ô∏è Text "${selectedText.slice(0, 30)}..." not found, appending to end`)
  if (newContent.content?.children) {
    newContent.content.children.push({
      type: 'Section',
      children: [annotation]
    })
  }
  
  return newContent
}

/**
 * Commit and push to Git
 */
async function commitAndPush(filePath, message) {
  try {
    const relativePath = path.relative(TUTORIALS_REPO, filePath)
    const safeMessage = message.replace(/"/g, '\\"').replace(/`/g, '\\`').replace(/\$/g, '\\$')
    execSync(`git add "${relativePath}"`, { cwd: TUTORIALS_REPO, stdio: 'pipe' })
    execSync(`git commit -m "${safeMessage}"`, { cwd: TUTORIALS_REPO, stdio: 'pipe' })
    execSync('git push', { cwd: TUTORIALS_REPO, stdio: 'pipe' })
    console.log(`‚úÖ Git: ${message}`)
    return true
  } catch (error) {
    console.log(`‚ö†Ô∏è Git failed: ${error.message?.slice(0, 100)}`)
    return false
  }
}

/**
 * Handle requests
 */
const server = http.createServer(async (req, res) => {
  const url = new URL(req.url, `http://localhost:${PORT}`)
  
  if (req.method === 'OPTIONS') {
    res.writeHead(204, {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type'
    })
    return res.end()
  }
  
  if (url.pathname === '/health' && req.method === 'GET') {
    const aiInfo = getAIInfo()
    return sendJson(res, 200, { 
      status: 'ok', 
      timestamp: new Date().toISOString(),
      ai: aiInfo
    })
  }
  
  if (url.pathname === '/tutorials' && req.method === 'GET') {
    try {
      const files = await fs.readdir(CONTENT_DIR)
      const tutorials = files.filter(f => f.endsWith('.json')).map(f => f.replace('.json', ''))
      return sendJson(res, 200, { tutorials })
    } catch (error) {
      return sendJson(res, 500, { error: error.message })
    }
  }
  
  if (url.pathname === '/annotate' && req.method === 'POST') {
    try {
      const body = await parseBody(req)
      const { action, selectedText, context, tutorialId } = body
      
      console.log('\nüìù Annotation Request:')
      console.log(`  Action: ${action}`)
      console.log(`  Tutorial: ${tutorialId}`)
      console.log(`  Selected: "${selectedText?.slice(0, 50)}..."`)
      
      if (!action || !selectedText || !tutorialId) {
        return sendJson(res, 400, { error: 'Missing required fields' })
      }
      
      if (!['explain', 'branch'].includes(action)) {
        return sendJson(res, 400, { error: 'Action must be explain or branch' })
      }
      
      const jsonPath = path.join(CONTENT_DIR, `${tutorialId}.json`)
      let content
      try {
        content = JSON.parse(await fs.readFile(jsonPath, 'utf-8'))
      } catch {
        return sendJson(res, 404, { error: `Tutorial not found: ${tutorialId}` })
      }
      
      console.log(`ü§ñ Generating ${action} annotation...`)
      const annotation = await generateAnnotation(
        action, 
        selectedText, 
        context || '', 
        content.title
      )
      if (!annotation) {
        return sendJson(res, 500, { error: 'Failed to generate annotation' })
      }
      console.log(`‚úÖ Annotation generated`)
      
      const updatedContent = insertAnnotation(content, selectedText, annotation, action)
      
      await fs.writeFile(jsonPath, JSON.stringify(updatedContent, null, 2))
      console.log(`üíæ Saved: ${jsonPath}`)
      
      const commitMsg = `[${action}] "${selectedText.slice(0, 40)}..." in ${tutorialId}`
      commitAndPush(jsonPath, commitMsg).catch(() => {})
      
      return sendJson(res, 200, {
        success: true,
        action,
        tutorialId,
        selectedText,
        updatedContent
      })
      
    } catch (error) {
      console.error('‚ùå Error:', error)
      return sendJson(res, 500, { error: error.message })
    }
  }
  
  sendJson(res, 404, { error: 'Not found' })
})

// Start server
const aiInfo = getAIInfo()
server.listen(PORT, () => {
  console.log(`\nüöÄ Annotation Server: http://localhost:${PORT}`)
  console.log(`\nü§ñ AI Provider: ${aiInfo.provider}`)
  console.log(`   Model: ${aiInfo.model}`)
  if (aiInfo.region) console.log(`   Region: ${aiInfo.region}`)
  console.log(`\n   To switch providers, edit: ai-config.js`)
  console.log(`\nEndpoints:`)
  console.log(`  POST /annotate  - Create annotation`)
  console.log(`  GET  /health    - Health check`)
  console.log(`  GET  /tutorials - List tutorials`)
  console.log(`\nContent: ${CONTENT_DIR}`)
})
